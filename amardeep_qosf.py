# -*- coding: utf-8 -*-
"""Amardeep_QOSF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M3nvcXwTb9cs91iTMjkDON4GiNlpizSM

##Task 1 find the primes numbers
"""

!pip install qiskit

!pip install qiskit-aer

from qiskit import QuantumCircuit, Aer, execute
from qiskit.circuit.library import QFT

def find_the_primes_numbers(number_1, prime_list):
    # Determine the number of qubits needed to represent the prime numbers
    num_qubits = len(bin(max(prime_list))) - 2

    # Create a quantum circuit with the required number of qubits
    circuit = QuantumCircuit(num_qubits + 1, num_qubits)

    # Apply the QFT on the qubits
    circuit.append(QFT(num_qubits), range(num_qubits))

    # Apply the phase estimation algorithm
    circuit.p(2 * number_1 / (2 ** num_qubits), range(num_qubits))

    # Apply the inverse QFT
    circuit.append(QFT(num_qubits).inverse(), range(num_qubits))

    # Measure the qubits
    circuit.measure(range(num_qubits), range(num_qubits))

    # Simulate the circuit
    simulator = Aer.get_backend('qasm_simulator')
    job = execute(circuit, simulator, shots=1)
    result = job.result()
    counts = result.get_counts()

    # Find the prime numbers
    number_a, number_b = '', ''
    for key in counts:
        binary = key[::-1]
        if binary in prime_list:
            if number_a == '':
                number_a = binary
            else:
                number_b = binary
                break

    return number_a
    print(number_b)

find_the_primes_numbers (18,[1,3,5,7,11,13,15])

import pennylane as qml
import numpy as np

def cost_function(x, number_1, prime_list):
    # Convert the binary representation to prime numbers
    primes = [prime_list[i] for i in range(len(x)) if x[i] == 1]

    # Calculate the sum of the prime numbers
    total = sum(primes)

    # Calculate the cost as the absolute difference between the sum and number_1
    cost = abs(total - number_1)

    return cost

def find_the_primes_numbers(number_1, prime_list):
    num_qubits = len(prime_list)
    num_layers = 2  # Number of QAOA layers

    # Create a PennyLane quantum device
    dev = qml.device("default.qubit", wires=num_qubits)

    # Define the QAOA circuit
    @qml.qnode(dev)
    def circuit(x, number_1, prime_list):
        # Apply the Hadamard gate to initialize the qubits
        qml.Hadamard(wires=range(num_qubits))

        # Apply the QAOA layers
        for i in range(num_layers):
            # Apply the cost Hamiltonian
            qml.cost.Hamiltonian(cost_function, coef=1, wires=range(num_qubits), dependencies=[number_1, prime_list])

            # Apply the mixer Hamiltonian
            qml.mixer.Hamiltonian(qml.PauliX, wires=range(num_qubits))

        # Measure the qubits
        return qml.probs(wires=range(num_qubits))

    # Optimize the circuit to find the solution
    opt = qml.GradientDescentOptimizer(stepsize=0.4)
    params = np.random.uniform(0, 2 * np.pi, (num_layers, num_qubits))
    best_cost = np.inf
    best_solution = None

    for i in range(100):
        params, cost = opt.step_and_cost(lambda params: circuit(params, number_1, prime_list), params)

        if cost < best_cost:
            best_cost = cost
            best_solution = params

    # Convert the binary representation to prime numbers
    binary_solution = [int(round(x)) for x in best_solution[0]]
    primes = [prime_list[i] for i in range(len(binary_solution)) if binary_solution[i] == 1]

    return ','.join(map(str, primes))

"""##Task 2 find negative values"""

!pip install pennylane

!pip install qiskit.aqua

def find_negative_numbers(list_number):
    num_qubits = len(list_number)  # Number of qubits needed is equal to the length of the input list

    # Create a quantum circuit with the required number of qubits
    circuit = QuantumCircuit(num_qubits, num_qubits)

    # Apply X-gate to qubits corresponding to negative numbers
    for i, num in enumerate(list_number):
        if num < 0:
            circuit.x(i)

    # Measure the qubits
    circuit.measure(range(num_qubits), range(num_qubits))

    # Simulate the circuit
    backend = Aer.get_backend('qasm_simulator')
    job = execute(circuit, backend, shots=1)
    result = job.result()

    # Extract the measurement result
    counts = result.get_counts(circuit)
    measurement = list(counts.keys())[0]

    # Check if any of the measured qubits is in the state '1'
    has_negative = any(bit == '1' for bit in measurement)

    return has_negative

B = find_negative_numbers([-15,-14,2,-1])
print(B)

A = find_negative_numbers([1,-3,2,15])
print(A)

B = find_negative_numbers([1,4,8,11])
print(B)